二、序列

1  divmod // %，获得的为一个元组，第一个值为地板除的结果，第二个为余数。（quotient、remainder）;

2 、看一下格式化的含义，对齐方式与浮点数位数;

3、具名元组：namedtuple，是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类，用namedtuple构建的实例所消耗的内存跟元组一样；

   构建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象或者由空格分隔开的字段名组成的字符串。

   [例如：namedtuple('City', ['name', 'country', 'population', 'coordatinates'])或namedtuple('City', 'name country population coordinates')]

   具名元组可以通过_make()接受一个可迭代对象来生成这个类的一个实例；作用跟4中的*运算符加可迭代对象是相同的。
  
   具名元组可以通过_asdict()把具名元组以collections.Ordereddict的形式返回，显示形式为一个字典形式，可以更加友好地把元组里的信息显示出来。

   _fields属性是一个包含这个类所有字段名称的元组。

4、可以用*运算符加变量的形式把一个可迭代的对象拆开作为函数的参数。

5、切片和区间不包含区间范围里的最后一个元素是python的风格，同时符合Python、C和其他语言里以0作为起始下标的传统。

6、S[a:b:c] 对s在a和b之间以c为间隔取值;对seq[start:stop:step]进行求值的时候，Python会调用seq.__getitem__(slice(start, stop, step))。

7、可以通过对切片进行命名来获取对应的我们需要的一段字符串或其他可迭代序列中的某一个或某一段元素。

8、多维切片和省略[略过……]

9、对切片赋值：如果赋值的对象是一个切片，那么赋值语句右侧必须是一个可迭代对象。

10、+ 和 * 不修改原有的操作对象，而是构建一个全新的序列。[在生成新序列的时候，如果直接使用+或者*生成的序列，均指向同一个列表的引用，修改会同步修改。]

    例如：row = ['_'] * 3 board = [] for i in range(3):board.append(row) board[1][2] = '+' 这样就会修改board中的所有值的第三项的值。

11、+= 和 *= 对应调用的特殊方法分别为__iadd__ 和 __imul__,+= 被称为“就地加法”。

12、列表在使用增量加法或增量乘法之后，列表的ID不会发生变化，新元素会直接追加到列表上；而元组在使用同样的算法之后，会创建新的元组。

13、dis 在python3中使用的时候，dis.dis()[Return a formatted view of the bytecode operations.]。

14、例子：

    t = (1, 2, [30, 40])
  
    t[2] += [50, 60]

    t的结果会发生变化，但是会报TypeError异常，因为tuple不支持对它的元素进行赋值。上述的例子，由于t2为list所以可以完成生成新的列表，但是在赋值给t的时候就会报错，因为tuple不支持对它的元素进行赋值。

15、** 需要看字符串的格式化的知识，例如：ROW_FMT = '{0:2d} @ {1:2d}    {2}{0:2d}' ，详情见bisect， 流畅的python 81页。

16、bisect相当于bisect_right，另外一个为bisect_left，插入的位置有所区别，一个在后，一个在前 。

17、** random.seed(1729) 的意思是什么？

    random.randrange() 随机返回一个iterable中的值。

18、bisect.insort() 插入一个值到一个序列中， 并保持原来的排序。

19、array表示数组，数组支持可变序列(如list)相关的所有操作，包括.pop、.insert和.extend，另外数组还提供从文件读取和存入文件的更快的方法，如.frombytes和.tofile。

    array必须指定typecode，如下：

    b signed integer 1 bytes
 
    B unsigned	     1

    u Unicode character 2

    h s		     2

    H uns	     2

    i s		     2

    I uns	     2

    l s		     4

    L uns	     4

    q s              8

    Q uns	     8

    f flaoting point 4

    d f              8


20、内存视图(memoryview)是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。

    例子：ch2_memory.py 中只能使用python3,不能使用python2。同时需要了解无符号整数与有符号整数之间的转换是如何进行转换的。

21、了解知识：Numpy、Scipy可以提供高阶数组和矩阵操作，让Python成为科学计算的主流语言。

    Numpy实现了多维同质数组和矩阵，这些数据结构不但能够处理数字，还能存放其他用户定义的记录。

    Scipy是基于Numpy的一个库，它提供了很多跟科学计算相关的算法，专为线性代数、数值积分和统计学而设计。Scipy的高效和可靠性主要归功于其背后的C和Fortran代码，而这些跟计算有关的部分都源自于Netlib库。

    安装方法：sudo apt-get install python-numpy python-scipy

22、队列

    双向队列(collections.deque)是一个线程安全、可以快速从两端添加或删除元素的数据类型。

    deque.rotate,可以接受一个参数n，当n>0的时候，队列的最右边的n个元素会被移动到队列的左边，当n<0的时候，最左边的n个元素会被移动到最右边。

23、内置序列类型总结：

    容器序列：list、tuple、collections.deque等序列类型能存放不同类型的数据。

    扁平序列：str、bytes、bytearray、memoryview和array.array等只能容纳一种类型。

    容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。扁平序列是一段连续的内存空间。


    按照能否修改分为可变序列和不可变序列：

    可变序列：list、bytearray、array、array、collections.deque和memoryview。

    不可变序列：tuple、str和bytes。

24、可变序列的功能：__setitem__ __delitem__ insert append reverse extend pop remove __iadd__
 
    不可变序列的功能：__getitem__ __contains__ __iter__ __reversed__ index count


三、字典

1、跟字典有关的内置函数都在__builtins__.__dict__中可以查看。

2、***** 散列表是字典类型性能出众的根本原因。

         字典在Python中被广泛使用，它是Python的基石，例如：变量的命名空间、实例的属性和函数的关键字参数都可以看到字典的身影。

3、** 什么是可散列的数据类型：

   如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个散列对象需要实现__hash__()方法。
   
   另外这个可散列对象还要有__qe__()方法，这样才能跟其他键做比较。

   如果两个散列对象是相等的，那么它们的散列值一定是一样的。如果一个对象是可散列的，散列值就是它们的id()函数的返回值。

4、字典推导(dictcomp)：可以从任何键值对作为元素的可迭代对象构建出字典。


第四章 文本和字节序列

1、字符问题

python3：str()->>>unicode字符；

python2：unicode()->>>unicode字符,str()对象获取的是原始字节序列。

2、unicode介绍

unicode标准把字符的标识和具体的字节表述进行了如下的区分：

A、字符的表示：即码位，类似0~1 114 111的数字(十进制)，在Unicode标准中以4~6个十六进制数字表示，而且前缀加“U+”。例如：A的码位是U+0041……

B、字符的具体表述取决于所用的编码。

编码是在码位和字节序列之间转换时使用的算法。

编码(encode)：把码位转换成序列的过程；【通俗解读：把字符串变成用于存储或传输的字节序列。】

解码(decode)：把字节序列转换成码位的过程。【通俗解读：把字节序列转换成人类可读的文本字符串。】

3、字节概要

python3中的bytes或bytearray对象的各个元素介于0~255(含)之间的整数，而不像python2的str对象那样是单个的字符。【不懂的地方：python2的str对象代表的意义，后续学习】

二进制序列实际上是整数序列，但是它们的字面量表示法表明其中有ASCII文本。因此，各个字节的值可能会使用下列三种不同的方式显示：

A、可打印的ASCII范围内的字节（从空格到~）,使用ASCII字符本身；

B、制表符、换行符、回车符和\对应的字节，使用转义序列\t、\n、\r和\\；

C、其他字节的值，使用十六进制的转义序列(例如：\x00是空字节)。

4、如何构建bytes的实例【具体可以参见：ch4_create_bytes_or_bytearray_instance】

A、一个str对象和一个encoding关键字参数；

B、一个可迭代对象，提供0~255之间的数值；

C、一个实现缓冲协议的对象（如bytes、bytearray、memoryview、array.array），把源对象中的字节序列复制到新建的二进制序列中。

4、结构体(struct)和内存视图(memoryview)

struct模块提供了一些函数，把打包的字节序列转换成不同类型字段组成的元组。

struct模块能处理bytes、bytearray和memoryview对象。



      

第八章 对象引用、可变性和垃圾回收

1、变量不是盒子

例如：a = [1, 2, 3]
      b = a
      a.append(4)

上述例子中b的结果同样会发生变化，所以应该把变量视作“便利贴”而不是“盒子”。

2、创建对象才会把对象分配给变量，上述的例子中便可以理解为：先创建右边的列表对象而后把这个对象分配给a。

3、标识、相等性和别名

== 比较两个对象的值（对象中保存的数据），而is比较对象的标识(标识可以用id()进行查看)。

*****标识：程序中使用is进行比较;

*****相等性： 程序中使用==进行判断;

*****别名：理解上类似于笔名，常见的如变量赋值。

在使用python过程中，==比is出现的频率高，主要是我们大多数时候关注的是值，而不是标识。但是在变量和单例值之家比较时，最常使用is检查绑定的值是不是None。

4、默认做浅复制，只复制最外层容器，副本中的元素是源容器中元素的引用，也就是副本共享源容器中元素的引用，修改任意一个副本都有可能导致源容器中的元素发生改变，尤其是修改源容器中的可变序列的元素。

5、函数参数问题：

   Python唯一支持的参数传递模式是共享传参(call by sharing)。

   共享传参指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。

   ***** 函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识。

   经典例子：幽灵乘客(HauntedBus)：指的是传入的参数为可变对象，会产生共享乘客的现象，共享乘客存放在类名.__init__.__defaults__中。

   ***** 注意：传参的时候不要使用可变对象，如果需要使用默认值，可以使用单例值None，然后在函数体中进行判断。

6、接5的问题继续

   twilightbus问题：如果默认参数值为None，但是传入的为一个可变对象，在判断的时候直接赋值给self.passerngers，这样在乘客下车的时候，会直接修改传入的值，假设传进来的参数为一个篮球队，这样篮球队里的人会出现

   凭空消失的问题。(具体可以参见例子：ch8_twilightbus.py)

7、总计5、6

   在类中直接把参数赋值给实例变量之前一定要三思，因为这样会为参数创建别名，如果不确定就创建副本，这样客户会减少麻烦。

   创建列表副本的方法：可以使用list内置函数、全切片、浅拷贝等方法。

8、del和垃圾回收

   del命令删除名称，而不是对象，而del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用或者无法得到对象时。

   重新绑定也会可能会导致对象的引用数量归零，导致对象被销毁。

   ** 注意：在编写代码中，尽量避免使用__del__方法，它并不会销毁实例，而是在即将销毁实例时进行调用，给实例最后的机会，释放外部资源。

   ***** 在CPython中，垃圾回收使用的主要方法是引用计数。

   实际上，每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即被销毁。

   ****** CPython 2.0 增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组。如果一组对象之间全部是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。

   例子：相互引用 a = [1, 2] b = [a, 30] a.append(b) [详情参见：例8-10 fluent python]


9、weakref的使用：在演示一个对象生命结束的时候的情形，可以通过weakref.finalize注册一个回调函数，在销毁对象的时候进行调用。[详情请参见例子：ch8_weakref_obj_garbage.py]

10、弱引用

    正是因为有了引用，对象才会在内存中存在，当对象的引用数量归零之后，垃圾回收程序才会把对象销毁。

    有时候需要引用对象，而不让对象存在的时间超过所需时间，常用在缓存的使用中。

    ***** 弱引用不会增加对象的引用数量，引用的目标对象被称为所指对象(referent)。弱引用不会妨碍所指对象被当作垃圾回收。


11、** Python控制台会话中，会把_变量绑定到结果不为None的表达式结果上。[暂时不知道如何去验证，但是根据《流畅的python》一书中例子：8-17确实可以看得出来]

12、weakref集合和finalize

    weakref集合包含WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize(在内部使用弱引用)。

    WeakValueDictionary类实现的是一种可变映射，里面的值是对对象的弱引用，被引用的对象在程序中的其他地方被当作垃圾回收之后，对应的键自动从WeakValueDictionary中删除。因此，WeakValueDictionary常用于缓存。

13、弱引用的局限
  
    不是每个Python对象都可以作为弱引用的目标，基本的list和dict的实例不能作为所指对象，但是它们的子类可以。

    set实例可以作为所指对象，int和tuple实例以及子类都不能作为弱引用的目标。（可以通过weakref.ref(所指对象)来验证当前结论）

14、驻留（interning）：共享字符串字面量是一种优化措施，同样对于小的整数也会使用这个优化措施，防止重复创建“热门数字”。

    ** 但是CPython不会驻留所有字符串和整数，驻留的条件是实现细节，而且没有文档说明。

    ***** 比较字符串或整数是否相等一定要使用==而不是is。

    ** 驻留是python解释器内部使用的一个特性。

15、本章总结：

    简单的赋值不创建副本;

    对+=和*=所做的增量赋值，如果左边的变量绑定的是不可变对象会创建新对象，如果是可变对象会就地修改。

    为现有的变量赋予新值，不会修改之前的变量，这叫做重新绑定。现在变量绑定了其他对象，如果该变量是对之前那个对象的最后一个应用，对象会被当作垃圾回收。

    函数的参数以别名的形式进行传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为不可避免，除非在本地创建副本或者使用不可变对象（例如传入元组而不传入列表）。

    使用可变对象作为函数的默认参数值非常危险，因为如果就地修改了参数，默认值也就发生了变化，这样会影响以后使用默认值的调用。

第十二章 继承的优缺点

1、在python2.2之后，内置类型可以子类化，但有个重要的注意事项，内置类型(使用c语言编写)不会调用用户定义的类覆盖的特殊方法。

   [原生类型的这种行为违背了面向对象编程的一个基本原则：始终应该从实例(self)所属的类开始搜索方法，即使在超类的实现中调用也是如此。]

   ** 注意：不要子类化内置类型，用户自定义的类应该继承collections模块中的类，例如：UserDict、UserList和UserString，这些类做过特殊设计，因此容易扩展。

2、多重继承和方法解析顺序

   任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起。这种冲突被成为“菱形”问题。

   超类中的方法都可以直接调用，此时要把实例作为显示参数传入。

   python会按照特定的调用顺序遍历继承图。这个顺序叫方法解析顺序(Method Resolution Order， MRO)。类都有一个名为__mro__的属性，它的值是一个元组。

   ** 注意：直接在类上调用实例方法，必须显示传入self参数，因为这样访问的是未绑定方法(unbound method).

   ** 然而，使用super()最安全，也不易过时。使用super()方法，会遵守方法解析顺序。

   ** 方法解析顺序使用C3算法计算。[了解即可]
    


















































额外补充：

1、Python是基于值的内存管理方式，同一个值的不同变量，则内存中只有一份该值，多个变量指向同一块内存地址。[适用于数字以及字符串等存储单个值的对象]

2、sort和sorted的区别：

   sort是list的方法，改变list对象的顺序，返回值为None；

   sorted是Python的内置方法，适用于iterable对象，返回值是新列表，不影响原来的iterable的顺序。

3、Celery n.芹菜、香芹粉、芹菜籽

   一个基于Python开发的分布式异步消息任务队列，通过它可以轻松地实现任务的异步处理。

   Celery在执行任务的时候需要通过一个中间件（broker）来接收和发送任务信息以及储存任务结果，一般使用rabbitMQ（默认）或Redis。
























































